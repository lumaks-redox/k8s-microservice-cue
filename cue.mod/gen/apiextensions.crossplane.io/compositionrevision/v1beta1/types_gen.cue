// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f https://doc.crds.dev/raw/github.com/crossplane/crossplane@v1.19.1

package v1beta1

import "strings"

// A CompositionRevision represents a revision of a Composition.
// Crossplane
// creates new revisions when there are changes to the
// Composition.
//
// Crossplane creates and manages CompositionRevisions. Don't
// directly edit
// CompositionRevisions.
#CompositionRevision: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "apiextensions.crossplane.io/v1beta1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "CompositionRevision"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// CompositionRevisionSpec specifies the desired state of the
	// composition
	// revision.
	spec!: #CompositionRevisionSpec
}

// CompositionRevisionSpec specifies the desired state of the
// composition
// revision.
#CompositionRevisionSpec: {
	// CompositeTypeRef specifies the type of composite resource that
	// this
	// composition is compatible with.
	compositeTypeRef!: {
		// APIVersion of the type.
		apiVersion!: string

		// Kind of the type.
		kind!: string
	}

	// Mode controls what type or "mode" of Composition will be used.
	//
	// "Pipeline" indicates that a Composition specifies a pipeline of
	// Composition Functions, each of which is responsible for
	// producing
	// composed resources that Crossplane should create or update.
	//
	// "Resources" indicates that a Composition uses what is commonly
	// referred
	// to as "Patch & Transform" or P&T composition. This mode of
	// Composition
	// uses an array of resources, each a template for a composed
	// resource.
	//
	// All Compositions should use Pipeline mode. Resources mode is
	// deprecated.
	// Resources mode won't be removed in Crossplane 1.x, and will
	// remain the
	// default to avoid breaking legacy Compositions. However, it's no
	// longer
	// accepting new features, and only accepting security related bug
	// fixes.
	mode?: "Resources" | "Pipeline"

	// PatchSets define a named set of patches that may be included by
	// any
	// resource in this Composition. PatchSets cannot themselves refer
	// to other
	// PatchSets.
	//
	// PatchSets are only used by the "Resources" mode of Composition.
	// They
	// are ignored by other modes.
	//
	// Deprecated: Use Composition Functions instead.
	patchSets?: [...{
		// Name of this PatchSet.
		name!: string

		// Patches will be applied as an overlay to the base resource.
		patches!: [...{
			// Combine is the patch configuration for a CombineFromComposite
			// or
			// CombineToComposite patch.
			combine?: {
				// Strategy defines the strategy to use to combine the input
				// variable values.
				// Currently only string is supported.
				strategy!: "string"
				string?: {
					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt!: string
				}

				// Variables are the list of variables whose values will be
				// retrieved and
				// combined.
				variables!: [...{
					// FromFieldPath is the path of the field on the source whose
					// value is
					// to be used as input.
					fromFieldPath!: string
				}] & [_, ...]
			}

			// FromFieldPath is the path of the field on the resource whose
			// value is
			// to be used as input. Required when type is
			// FromCompositeFieldPath or
			// ToCompositeFieldPath.
			fromFieldPath?: string

			// PatchSetName to include patches from. Required when type is
			// PatchSet.
			patchSetName?: string

			// Policy configures the specifics of patching behaviour.
			policy?: {
				// FromFieldPath specifies how to patch from a field path. The
				// default is
				// 'Optional', which means the patch will be a no-op if the
				// specified
				// fromFieldPath does not exist. Use 'Required' if the patch
				// should fail if
				// the specified path does not exist.
				fromFieldPath?: "Optional" | "Required"

				// MergeOptions Specifies merge options on a field path.
				mergeOptions?: {
					// Specifies that already existing elements in a merged slice
					// should be preserved
					appendSlice?: bool

					// Specifies that already existing values in a merged map should
					// be preserved
					keepMapValues?: bool
				}
			}

			// ToFieldPath is the path of the field on the resource whose
			// value will
			// be changed with the result of transforms. Leave empty if you'd
			// like to
			// propagate to the same path as fromFieldPath.
			toFieldPath?: string

			// Transforms are the list of functions that are used as a FIFO
			// pipe for the
			// input to be transformed.
			transforms?: [...{
				// Convert is used to cast the input into the given output type.
				convert?: {
					// The expected input format.
					//
					// * `quantity` - parses the input as a K8s
					// [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
					// Only used during `string -> float64` conversions.
					// * `json` - parses the input as a JSON string.
					// Only used during `string -> object` or `string -> list`
					// conversions.
					//
					// If this property is null, the default conversion is applied.
					format?: "none" | "quantity" | "json"

					// ToType is the type of the output of this transform.
					toType!: "string" | "int" | "int64" | "bool" | "float64" | "object" | "array"
				}

				// Map uses the input as a key in the given map and returns the
				// value.
				map?: close({
					[string]: _
				})

				// Match is a more complex version of Map that matches a list of
				// patterns.
				match?: {
					// Determines to what value the transform should fallback if no
					// pattern matches.
					fallbackTo?: "Value" | "Input"

					// The fallback value that should be returned by the transform if
					// now pattern
					// matches.
					fallbackValue?: _

					// The patterns that should be tested against the input string.
					// Patterns are tested in order. The value of the first match is
					// used as
					// result of this transform.
					patterns?: [...{
						// Literal exactly matches the input string (case sensitive).
						// Is required if `type` is `literal`.
						literal?: string

						// Regexp to match against the input string.
						// Is required if `type` is `regexp`.
						regexp?: string

						// The value that is used as result of the transform if the
						// pattern matches.
						result!: _

						// Type specifies how the pattern matches the input.
						//
						// * `literal` - the pattern value has to exactly match (case
						// sensitive) the
						// input string. This is the default.
						//
						// * `regexp` - the pattern treated as a regular expression
						// against
						// which the input string is tested. Crossplane will throw an
						// error if the
						// key is not a valid regexp.
						type!: "literal" | "regexp"
					}]
				}

				// Math is used to transform the input via mathematical operations
				// such as
				// multiplication.
				math?: {
					// ClampMax makes sure that the value is not bigger than the given
					// value.
					clampMax?: int64

					// ClampMin makes sure that the value is not smaller than the
					// given value.
					clampMin?: int64

					// Multiply the value.
					multiply?: int64

					// Type of the math transform to be run.
					type?: "Multiply" | "ClampMin" | "ClampMax"
				}

				// String is used to transform the input into a string or a
				// different kind
				// of string. Note that the input does not necessarily need to be
				// a string.
				string?: {
					// Optional conversion method to be specified.
					// `ToUpper` and `ToLower` change the letter case of the input
					// string.
					// `ToBase64` and `FromBase64` perform a base64 conversion based
					// on the input string.
					// `ToJson` converts any input value into its raw JSON
					// representation.
					// `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based
					// on the input
					// converted to JSON.
					// `ToAdler32` generate a addler32 hash based on the input string.
					convert?: "ToUpper" | "ToLower" | "ToBase64" | "FromBase64" | "ToJson" | "ToSha1" | "ToSha256" | "ToSha512" | "ToAdler32"

					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt?: string
					join?: {
						// Separator defines the character that should separate the values
						// from each
						// other in the joined string.
						separator!: string
					}

					// Extract a match from the input using a regular expression.
					regexp?: {
						// Group number to match. 0 (the default) matches the entire
						// expression.
						group?: int

						// Match string. May optionally include submatches, aka capture
						// groups.
						// See https://pkg.go.dev/regexp/ for details.
						match!: string
					}

					// Trim the prefix or suffix from the input
					trim?: string

					// Type of the string transform to be run.
					type?: "Format" | "Convert" | "TrimPrefix" | "TrimSuffix" | "Regexp" | "Join"
				}

				// Type of the transform to be run.
				type!: "map" | "match" | "math" | "string" | "convert"
			}]

			// Type sets the patching behaviour to be used. Each patch type
			// may require
			// its own fields to be set on the Patch object.
			type?: "FromCompositeFieldPath" | "PatchSet" | "ToCompositeFieldPath" | "CombineFromComposite" | "CombineToComposite"
		}]
	}]

	// Pipeline is a list of composition function steps that will be
	// used when a
	// composite resource referring to this composition is created.
	// One of
	// resources and pipeline must be specified - you cannot specify
	// both.
	//
	// The Pipeline is only used by the "Pipeline" mode of
	// Composition. It is
	// ignored by other modes.
	pipeline?: [...{
		// Credentials are optional credentials that the Composition
		// Function needs.
		credentials?: [...{
			// Name of this set of credentials.
			name!: string

			// A SecretRef is a reference to a secret containing credentials
			// that should
			// be supplied to the function.
			secretRef?: {
				// Name of the secret.
				name!: string

				// Namespace of the secret.
				namespace!: string
			}

			// Source of the function credentials.
			source!: "None" | "Secret"
		}]
		functionRef!: {
			// Name of the referenced Function.
			name!: string
		}

		// Input is an optional, arbitrary Kubernetes resource (i.e. a
		// resource
		// with an apiVersion and kind) that will be passed to the
		// Composition
		// Function as the 'input' of its RunFunctionRequest.
		input?: {}

		// Step name. Must be unique within its Pipeline.
		step!: string
	}]
	publishConnectionDetailsWithStoreConfigRef?: {
		// Name of the referenced StoreConfig.
		name!: string
	}

	// Resources is a list of resource templates that will be used
	// when a
	// composite resource referring to this composition is created.
	//
	// Resources are only used by the "Resources" mode of Composition.
	// They are
	// ignored by other modes.
	//
	// Deprecated: Use Composition Functions instead.
	resources?: [...{
		// Base is the target resource that the patches will be applied
		// on.
		base!: {}

		// ConnectionDetails lists the propagation secret keys from this
		// target
		// resource to the composition instance connection secret.
		connectionDetails?: [...{
			// FromConnectionSecretKey is the key that will be used to fetch
			// the value
			// from the composed resource's connection secret.
			fromConnectionSecretKey?: string

			// FromFieldPath is the path of the field on the composed resource
			// whose
			// value to be used as input. Name must be specified if the type
			// is
			// FromFieldPath.
			fromFieldPath?: string

			// Name of the connection secret key that will be propagated to
			// the
			// connection secret of the composition instance. Leave empty if
			// you'd like
			// to use the same key name.
			name?: string

			// Type sets the connection detail fetching behaviour to be used.
			// Each
			// connection detail type may require its own fields to be set on
			// the
			// ConnectionDetail object. If the type is omitted Crossplane will
			// attempt
			// to infer it based on which other fields were specified. If
			// multiple
			// fields are specified the order of precedence is:
			// 1. FromValue
			// 2. FromConnectionSecretKey
			// 3. FromFieldPath
			type?: "FromConnectionSecretKey" | "FromFieldPath" | "FromValue"

			// Value that will be propagated to the connection secret of the
			// composite
			// resource. May be set to inject a fixed, non-sensitive
			// connection secret
			// value, for example a well-known port.
			value?: string
		}]

		// A Name uniquely identifies this entry within its Composition's
		// resources
		// array. Names are optional but *strongly* recommended. When all
		// entries in
		// the resources array are named entries may added, deleted, and
		// reordered
		// as long as their names do not change. When entries are not
		// named the
		// length and order of the resources array should be treated as
		// immutable.
		// Either all or no entries must be named.
		name?: string

		// Patches will be applied as overlay to the base resource.
		patches?: [...{
			// Combine is the patch configuration for a CombineFromComposite
			// or
			// CombineToComposite patch.
			combine?: {
				// Strategy defines the strategy to use to combine the input
				// variable values.
				// Currently only string is supported.
				strategy!: "string"
				string?: {
					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt!: string
				}

				// Variables are the list of variables whose values will be
				// retrieved and
				// combined.
				variables!: [...{
					// FromFieldPath is the path of the field on the source whose
					// value is
					// to be used as input.
					fromFieldPath!: string
				}] & [_, ...]
			}

			// FromFieldPath is the path of the field on the resource whose
			// value is
			// to be used as input. Required when type is
			// FromCompositeFieldPath or
			// ToCompositeFieldPath.
			fromFieldPath?: string

			// PatchSetName to include patches from. Required when type is
			// PatchSet.
			patchSetName?: string

			// Policy configures the specifics of patching behaviour.
			policy?: {
				// FromFieldPath specifies how to patch from a field path. The
				// default is
				// 'Optional', which means the patch will be a no-op if the
				// specified
				// fromFieldPath does not exist. Use 'Required' if the patch
				// should fail if
				// the specified path does not exist.
				fromFieldPath?: "Optional" | "Required"

				// MergeOptions Specifies merge options on a field path.
				mergeOptions?: {
					// Specifies that already existing elements in a merged slice
					// should be preserved
					appendSlice?: bool

					// Specifies that already existing values in a merged map should
					// be preserved
					keepMapValues?: bool
				}
			}

			// ToFieldPath is the path of the field on the resource whose
			// value will
			// be changed with the result of transforms. Leave empty if you'd
			// like to
			// propagate to the same path as fromFieldPath.
			toFieldPath?: string

			// Transforms are the list of functions that are used as a FIFO
			// pipe for the
			// input to be transformed.
			transforms?: [...{
				// Convert is used to cast the input into the given output type.
				convert?: {
					// The expected input format.
					//
					// * `quantity` - parses the input as a K8s
					// [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
					// Only used during `string -> float64` conversions.
					// * `json` - parses the input as a JSON string.
					// Only used during `string -> object` or `string -> list`
					// conversions.
					//
					// If this property is null, the default conversion is applied.
					format?: "none" | "quantity" | "json"

					// ToType is the type of the output of this transform.
					toType!: "string" | "int" | "int64" | "bool" | "float64" | "object" | "array"
				}

				// Map uses the input as a key in the given map and returns the
				// value.
				map?: close({
					[string]: _
				})

				// Match is a more complex version of Map that matches a list of
				// patterns.
				match?: {
					// Determines to what value the transform should fallback if no
					// pattern matches.
					fallbackTo?: "Value" | "Input"

					// The fallback value that should be returned by the transform if
					// now pattern
					// matches.
					fallbackValue?: _

					// The patterns that should be tested against the input string.
					// Patterns are tested in order. The value of the first match is
					// used as
					// result of this transform.
					patterns?: [...{
						// Literal exactly matches the input string (case sensitive).
						// Is required if `type` is `literal`.
						literal?: string

						// Regexp to match against the input string.
						// Is required if `type` is `regexp`.
						regexp?: string

						// The value that is used as result of the transform if the
						// pattern matches.
						result!: _

						// Type specifies how the pattern matches the input.
						//
						// * `literal` - the pattern value has to exactly match (case
						// sensitive) the
						// input string. This is the default.
						//
						// * `regexp` - the pattern treated as a regular expression
						// against
						// which the input string is tested. Crossplane will throw an
						// error if the
						// key is not a valid regexp.
						type!: "literal" | "regexp"
					}]
				}

				// Math is used to transform the input via mathematical operations
				// such as
				// multiplication.
				math?: {
					// ClampMax makes sure that the value is not bigger than the given
					// value.
					clampMax?: int64

					// ClampMin makes sure that the value is not smaller than the
					// given value.
					clampMin?: int64

					// Multiply the value.
					multiply?: int64

					// Type of the math transform to be run.
					type?: "Multiply" | "ClampMin" | "ClampMax"
				}

				// String is used to transform the input into a string or a
				// different kind
				// of string. Note that the input does not necessarily need to be
				// a string.
				string?: {
					// Optional conversion method to be specified.
					// `ToUpper` and `ToLower` change the letter case of the input
					// string.
					// `ToBase64` and `FromBase64` perform a base64 conversion based
					// on the input string.
					// `ToJson` converts any input value into its raw JSON
					// representation.
					// `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based
					// on the input
					// converted to JSON.
					// `ToAdler32` generate a addler32 hash based on the input string.
					convert?: "ToUpper" | "ToLower" | "ToBase64" | "FromBase64" | "ToJson" | "ToSha1" | "ToSha256" | "ToSha512" | "ToAdler32"

					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt?: string
					join?: {
						// Separator defines the character that should separate the values
						// from each
						// other in the joined string.
						separator!: string
					}

					// Extract a match from the input using a regular expression.
					regexp?: {
						// Group number to match. 0 (the default) matches the entire
						// expression.
						group?: int

						// Match string. May optionally include submatches, aka capture
						// groups.
						// See https://pkg.go.dev/regexp/ for details.
						match!: string
					}

					// Trim the prefix or suffix from the input
					trim?: string

					// Type of the string transform to be run.
					type?: "Format" | "Convert" | "TrimPrefix" | "TrimSuffix" | "Regexp" | "Join"
				}

				// Type of the transform to be run.
				type!: "map" | "match" | "math" | "string" | "convert"
			}]

			// Type sets the patching behaviour to be used. Each patch type
			// may require
			// its own fields to be set on the Patch object.
			type?: "FromCompositeFieldPath" | "PatchSet" | "ToCompositeFieldPath" | "CombineFromComposite" | "CombineToComposite"
		}]

		// ReadinessChecks allows users to define custom readiness checks.
		// All checks
		// have to return true in order for resource to be considered
		// ready. The
		// default readiness check is to have the "Ready" condition to be
		// "True".
		readinessChecks?: [...{
			// FieldPath shows the path of the field whose value will be used.
			fieldPath?: string

			// MatchCondition specifies the condition you'd like to match if
			// you're using "MatchCondition" type.
			matchCondition?: {
				// Status is the status of the condition you'd like to match.
				status!: string

				// Type indicates the type of condition you'd like to use.
				type!: string
			}

			// MatchInt is the value you'd like to match if you're using
			// "MatchInt" type.
			matchInteger?: int64

			// MatchString is the value you'd like to match if you're using
			// "MatchString" type.
			matchString?: string

			// Type indicates the type of probe you'd like to use.
			type!: "MatchString" | "MatchInteger" | "NonEmpty" | "MatchCondition" | "MatchTrue" | "MatchFalse" | "None"
		}]
	}]

	// Revision number. Newer revisions have larger numbers.
	//
	// This number can change. When a Composition transitions from
	// state A
	// -> B -> A there will be only two CompositionRevisions.
	// Crossplane will
	// edit the original CompositionRevision to change its revision
	// number from
	// 0 to 2.
	revision!: int64

	// WriteConnectionSecretsToNamespace specifies the namespace in
	// which the
	// connection secrets of composite resource dynamically
	// provisioned using
	// this composition will be created.
	// This field is planned to be replaced in a future release in
	// favor of
	// PublishConnectionDetailsWithStoreConfigRef. Currently, both
	// could be
	// set independently and connection details would be published to
	// both
	// without affecting each other as long as related fields at MR
	// level
	// specified.
	writeConnectionSecretsToNamespace?: string
}
