// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f https://doc.crds.dev/raw/github.com/crossplane/crossplane@v1.19.1

package v1beta1

import "strings"

// The ImageConfig resource is used to configure settings for
// package images.
#ImageConfig: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "pkg.crossplane.io/v1beta1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "ImageConfig"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// ImageConfigSpec contains the configuration for matching images.
	spec!: #ImageConfigSpec
}

// ImageConfigSpec contains the configuration for matching images.
#ImageConfigSpec: {
	// MatchImages is a list of image matching rules that should be
	// satisfied.
	matchImages!: [...{
		// Prefix is the prefix that should be matched.
		prefix!: string

		// Type is the type of match.
		type?: "Prefix"
	}]
	registry?: {
		authentication?: {
			pullSecretRef!: {
				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string
			}
		}
	}

	// Verification contains the configuration for verifying the
	// image.
	verification?: {
		cosign?: {
			// Authorities defines the rules for discovering and validating
			// signatures.
			authorities!: [...{
				// Attestations is a list of individual attestations for this
				// authority,
				// once the signature for this authority has been verified.
				attestations?: [...{
					// Name of the attestation.
					name!: string

					// PredicateType defines which predicate type to verify. Matches
					// cosign
					// verify-attestation options.
					predicateType!: string
				}]

				// Key defines the type of key to validate the image.
				key?: {
					// HashAlgorithm always defaults to sha256 if the algorithm hasn't
					// been explicitly set
					hashAlgorithm!: string

					// SecretRef sets a reference to a secret with the key.
					secretRef!: {
						// The key to select.
						key!: string

						// Name of the secret.
						name!: string
					}
				}

				// Keyless sets the configuration to verify the authority against
				// a Fulcio
				// instance.
				keyless?: {
					// Identities sets a list of identities.
					identities!: [...{
						// Issuer defines the issuer for this identity.
						issuer?: string

						// IssuerRegExp specifies a regular expression to match the issuer
						// for this identity.
						// This has precedence over the Issuer field.
						issuerRegExp?: string

						// Subject defines the subject for this identity.
						subject?: string

						// SubjectRegExp specifies a regular expression to match the
						// subject for this identity.
						// This has precedence over the Subject field.
						subjectRegExp?: string
					}]

					// InsecureIgnoreSCT omits verifying if a certificate contains an
					// embedded SCT
					insecureIgnoreSCT?: bool
				}

				// Name is the name for this authority.
				name!: string
			}]
		}

		// Provider is the provider that should be used to verify the
		// image.
		provider!: "Cosign"
	}
}
